// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace Microsoft.Azure.WebJobs.Host.Bindings.Path
{
    /// <summary>
    /// Represents a semantic token as generated by <see cref="BindingTemplateParser"/> during parsing of parameterized 
    /// binding template string. Then generated token may be consumed to create instance of 
    /// <see cref="BindingTemplate"/> or <see cref="BindingTemplateSource"/>.
    /// The token may be a literal value or an expression. 
    /// </summary>
    internal abstract class BindingTemplateToken
    {
        // If this is expression, get the prameter name 
        // If it's a literal, return null.
        public abstract string ParameterName { get; }

        // If this is a literal, return the value. Else, return null.
        public abstract string AsLiteral { get; }

        public static BindingTemplateToken NewLiteral(string literalValue)
        {
            return new LiteralToken(literalValue);
        }

        public static BindingTemplateToken NewExpressions(string expression)
        {
            if (!BindingTemplateParser.IsValidIdentifier(expression))
            {
                throw new FormatException($"The parameter name '{expression}' is invalid.");
            }

            // BindingData takes precedence over builtins.  
            BindingParameterResolver builtin;
            BindingParameterResolver.TryGetResolver(expression, out builtin);

            // Expression is just a series of dot operators like:  a.b.c
            var parts = expression.Split('.');

            // For backwards compat, first time can't have a '-'
            if (builtin == null)
            {
                if (parts[0].IndexOf('-') >= 0)
                {
                    throw new FormatException($"The parameter name '{parts[0]}' is invalid.");
                }
            }

            foreach (var part in parts)
            {
                if (string.IsNullOrWhiteSpace(part))
                {
                    throw new InvalidOperationException($"Illegal expression: {parts}");
                }
            }

            if (builtin == null)
            {
                return new ExpressionToken(parts);
            }
            else
            {
                return new ExpressionTokenOrBuiltin(parts, builtin);
            }
        }

        public abstract string Evaluate(IReadOnlyDictionary<string, object> bindingData);

        protected abstract void BuildCapturePattern(StringBuilder builder);

        // Create a regex that will populate values of parameters by matching the template against an input string. 
        // this is used by triggers to populate binding data. 
        internal static string BuildCapturePattern(IEnumerable<BindingTemplateToken> tokens)
        {
            StringBuilder builder = new StringBuilder("^");

            foreach (var token in tokens)
            {
                token.BuildCapturePattern(builder);
            }

            return builder.Append("$").ToString();
        }

        // Represents a literal segment.
        private class LiteralToken : BindingTemplateToken
        {
            private readonly string _value;
            public LiteralToken(string value)
            {
                _value = value;
            }

            public override string AsLiteral
            {
                get
                {
                    return _value;
                }
            }

            public override string ParameterName
            {
                get
                {
                    return null;
                }
            }
            
            public override string Evaluate(IReadOnlyDictionary<string, object> bindingData)
            {
                return _value;
            }

            protected override void BuildCapturePattern(StringBuilder builder)
            {
                builder.Append(Regex.Escape(this._value));
            }
        }

        // Represent an expression. 
        //    "literal{expr}literal" 
        private class ExpressionToken : BindingTemplateToken
        {
            private readonly string[] _parts;

            public ExpressionToken(string[] parts)
            {
                _parts = parts;
            }

            public override string AsLiteral
            {
                get
                {
                    return null;
                }
            }

            public override string ParameterName
            {
                get
                {
                    return this._parts[0];
                }
            }

            protected override void BuildCapturePattern(StringBuilder builder)
            {
                if (this._parts.Length != 1)
                {
                    throw new InvalidOperationException($"Capture expressions can't include dot operators");
                }

                var value = this._parts[0];
                builder.Append(String.Format(CultureInfo.InvariantCulture, "(?<{0}>.*)", value));
            }

            protected virtual string Fallback()
            {
                // Derived class can provide fallback resolutions if we don't match binding data. 
                return null;
            }

            public override string Evaluate(IReadOnlyDictionary<string, object> bindingData)
            {
                object current;

                if (bindingData.TryGetValue(this._parts[0], out current))
                {
                    for (int i = 1; i < _parts.Length; i++)
                    {
                        var propName = _parts[i];

                        var type = current.GetType();

                        var prop = type.GetProperty(propName);
                        if (prop == null || !prop.CanRead)
                        {
                            throw new InvalidOperationException($"No readable property '{propName}'");
                        }
                        current = prop.GetValue(current);
                    }
                }
                else
                {
                    // Not found. Maybe a resolver can do it?
                    current = this.Fallback();
                }

                if (current == null)
                {
                    throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture, "No value for named parameter '{0}'.", this.ParameterName));
                }

                var strValue = BindingDataPathHelper.ConvertParameterValueToString(current);
                return strValue;
            }
        }

        // Represent expression that could also be a builtin resolver. 
        // For the builins, this could statically pull their formatting string too.
        private class ExpressionTokenOrBuiltin : ExpressionToken
        {
            private readonly BindingParameterResolver _resolver;

            public ExpressionTokenOrBuiltin(string[] parts, BindingParameterResolver resolver) : base(parts)
            {
                if (resolver == null)
                {
                    throw new ArgumentNullException(nameof(resolver));
                }
                _resolver = resolver;
            }
             
            // binding data gets first chance to claim it. 
            // If there's no binding data, then the fallback is invoked and we can match against the resolver.           
            protected override string Fallback()
            {
                var input = this.ParameterName; // may contains a format specified
                var result = _resolver.Resolve(input);

                return result;
            }
        }
    }
}
